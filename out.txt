#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use dioxus::prelude::*;
use views::Home;
mod components {
    mod hero {
        use dioxus::prelude::*;
        const HEADER_SVG: Asset = {
            const __ASSET_HASH: &[u8] = &[
                216u8, 0u8, 15u8, 82u8, 234u8, 184u8, 94u8, 34u8,
            ];
            const __ASSET_SOURCE_PATH: &'static str = "/Users/evanalmloff/Desktop/gitlucky/assets/header.svg";
            const __ASSET_OPTIONS: manganis::AssetOptions = manganis::AssetOptions::Unknown
                .into_asset_options();
            const __ASSET: manganis::BundledAsset = manganis::macro_helpers::create_bundled_asset(
                __ASSET_SOURCE_PATH,
                __ASSET_HASH,
                __ASSET_OPTIONS,
            );
            const __BUFFER: manganis::macro_helpers::const_serialize::ConstVec<u8> = manganis::macro_helpers::serialize_asset(
                &__ASSET,
            );
            const __BYTES: &[u8] = __BUFFER.as_ref();
            const __LEN: usize = __BYTES.len();
            #[link_section = "__DATA,manganis,regular,no_dead_strip"]
            #[used]
            static __LINK_SECTION: [u8; __LEN] = manganis::macro_helpers::copy_bytes(
                __BYTES,
            );
            fn __keep_link_section() -> u8 {
                unsafe { std::ptr::read_volatile(__LINK_SECTION.as_ptr()) }
            }
            manganis::Asset::new(__ASSET, __keep_link_section)
        };
        #[allow(non_snake_case)]
        pub fn Hero() -> Element {
            {
                dioxus_core::internal::verify_component_called_as_component(Hero);
                {
                    dioxus_core::Element::Ok({
                        let __dynamic_nodes: [dioxus_core::DynamicNode; 0usize] = [];
                        let __dynamic_attributes: [Box<
                            [dioxus_core::Attribute],
                        >; 1usize] = [
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::img::src.0,
                                        HEADER_SVG,
                                        dioxus_elements::img::src.1,
                                        dioxus_elements::img::src.2,
                                    )
                                },
                            ]),
                        ];
                        #[doc(hidden)]
                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                            {
                                dioxus_core::TemplateNode::Element {
                                    tag: dioxus_elements::elements::div::TAG_NAME,
                                    namespace: dioxus_elements::div::NAME_SPACE,
                                    attrs: &[
                                        dioxus_core::TemplateAttribute::Static {
                                            name: dioxus_elements::div::id.0,
                                            namespace: dioxus_elements::div::id.1,
                                            value: "hero",
                                        },
                                    ],
                                    children: &[
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::img::TAG_NAME,
                                                namespace: dioxus_elements::img::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Dynamic {
                                                        id: 0usize,
                                                    },
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::img::id.0,
                                                        namespace: dioxus_elements::img::id.1,
                                                        value: "header",
                                                    },
                                                ],
                                                children: &[],
                                            }
                                        },
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::div::TAG_NAME,
                                                namespace: dioxus_elements::div::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::div::id.0,
                                                        namespace: dioxus_elements::div::id.1,
                                                        value: "links",
                                                    },
                                                ],
                                                children: &[
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://dioxuslabs.com/learn/0.6/",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "ðŸ“š Learn Dioxus",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://dioxuslabs.com/awesome",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "ðŸš€ Awesome Dioxus",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://github.com/dioxus-community/",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "ðŸ“¡ Community Libraries",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://github.com/DioxusLabs/sdk",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "âš™\u{fe0f} Dioxus Development Kit",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://marketplace.visualstudio.com/items?itemName=DioxusLabs.dioxus",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "ðŸ’« VSCode Extension",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::a::TAG_NAME,
                                                            namespace: dioxus_elements::a::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::a::href.0,
                                                                    namespace: dioxus_elements::a::href.1,
                                                                    value: "https://discord.gg/XgGxMSkvUM",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Text {
                                                                    text: "ðŸ‘‹ Community Discord",
                                                                },
                                                            ],
                                                        }
                                                    },
                                                ],
                                            }
                                        },
                                    ],
                                }
                            },
                        ];
                        {
                            #[doc(hidden)]
                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                roots: __TEMPLATE_ROOTS,
                                node_paths: &[],
                                attr_paths: &[&[0u8, 0u8]],
                            };
                            #[allow(clippy::let_and_return)]
                            let __vnodes = dioxus_core::VNode::new(
                                None,
                                ___TEMPLATE,
                                Box::new(__dynamic_nodes),
                                Box::new(__dynamic_attributes),
                            );
                            __vnodes
                        }
                    })
                }
            }
        }
        #[allow(non_snake_case)]
        #[doc(hidden)]
        mod Hero_completions {
            #[doc(hidden)]
            #[allow(non_camel_case_types)]
            /// This enum is generated to help autocomplete the braces after the component. It does nothing
            pub enum Component {
                Hero {},
            }
        }
        #[allow(unused)]
        pub use Hero_completions::Component::Hero;
    }
    pub use hero::Hero;
}
mod server {}
mod views {
    mod home {
        use dioxus::prelude::*;
        use std::{fmt::Display, str::FromStr};
        enum TransitioningDirection {
            Left,
            Right,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TransitioningDirection {
            #[inline]
            fn clone(&self) -> TransitioningDirection {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TransitioningDirection {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransitioningDirection {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransitioningDirection {
            #[inline]
            fn eq(&self, other: &TransitioningDirection) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[allow(non_snake_case)]
        pub fn Home() -> Element {
            {
                dioxus_core::internal::verify_component_called_as_component(Home);
                {
                    let mut transitioning = use_signal(|| None);
                    let mut end_id = use_signal(|| 3);
                    dioxus_core::Element::Ok({
                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                            {
                                let ___nodes = ((end_id()
                                    - (3 + transitioning().is_some() as usize)..end_id())
                                    .rev())
                                    .into_iter()
                                    .map(|card| {
                                        dioxus_core::Element::Ok({
                                            let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                                dioxus_core::DynamicNode::Component({
                                                    use dioxus_core::prelude::Properties;
                                                    let __comp = ({
                                                        fc_to_builder(Card)
                                                            .class({
                                                                if let Some(dir) = transitioning() {
                                                                    if match card {
                                                                        tmp => {
                                                                            {
                                                                                ::std::io::_eprint(
                                                                                    format_args!(
                                                                                        "[{0}:{1}:{2}] {3} = {4:#?}\n",
                                                                                        "src/views/home.rs",
                                                                                        22u32,
                                                                                        64u32,
                                                                                        "card",
                                                                                        &tmp,
                                                                                    ),
                                                                                );
                                                                            };
                                                                            tmp
                                                                        }
                                                                    } == end_id()
                                                                    {
                                                                        "in-card"
                                                                    } else if card
                                                                        == end_id() - (3 + transitioning().is_some() as usize)
                                                                    {
                                                                        match dir {
                                                                            TransitioningDirection::Right => "right-card",
                                                                            TransitioningDirection::Left => "left-card",
                                                                        }
                                                                    } else {
                                                                        "down-card"
                                                                    }
                                                                } else {
                                                                    { #[allow(clippy::useless_conversion)] "card".into() }
                                                                }
                                                            })
                                                            .url({
                                                                { "https://github.com/floneum/floneum/pull/361.diff" }
                                                            })
                                                            .build()
                                                    })
                                                        .into_vcomponent(Card);
                                                    __comp
                                                }),
                                            ];
                                            let __dynamic_attributes: [Box<
                                                [dioxus_core::Attribute],
                                            >; 0usize] = [];
                                            #[doc(hidden)]
                                            static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                {
                                                    dioxus_core::TemplateNode::Element {
                                                        tag: dioxus_elements::elements::div::TAG_NAME,
                                                        namespace: dioxus_elements::div::NAME_SPACE,
                                                        attrs: &[],
                                                        children: &[],
                                                    }
                                                },
                                                dioxus_core::TemplateNode::Dynamic {
                                                    id: 0usize,
                                                },
                                            ];
                                            {
                                                #[doc(hidden)]
                                                static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                    roots: __TEMPLATE_ROOTS,
                                                    node_paths: &[&[1u8]],
                                                    attr_paths: &[],
                                                };
                                                #[allow(clippy::let_and_return)]
                                                let __vnodes = dioxus_core::VNode::new(
                                                    Some(
                                                        ::alloc::__export::must_use({
                                                                let res = ::alloc::fmt::format(format_args!("k-{0}", card));
                                                                res
                                                            })
                                                            .to_string(),
                                                    ),
                                                    ___TEMPLATE,
                                                    Box::new(__dynamic_nodes),
                                                    Box::new(__dynamic_attributes),
                                                );
                                                __vnodes
                                            }
                                        })
                                    })
                                    .into_dyn_node();
                                ___nodes
                            },
                        ];
                        let __dynamic_attributes: [Box<
                            [dioxus_core::Attribute],
                        >; 2usize] = [
                            Box::new([
                                {
                                    dioxus_elements::events::onclick::call_with_explicit_closure(move |
                                        _|
                                    async move {
                                        end_id += 1;
                                        transitioning.set(Some(TransitioningDirection::Left));
                                        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                                        transitioning.set(None);
                                    })
                                },
                            ]),
                            Box::new([
                                {
                                    dioxus_elements::events::onclick::call_with_explicit_closure(move |
                                        _|
                                    async move {
                                        end_id += 1;
                                        transitioning.set(Some(TransitioningDirection::Right));
                                        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
                                        transitioning.set(None);
                                    })
                                },
                            ]),
                        ];
                        #[doc(hidden)]
                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                            dioxus_core::TemplateNode::Dynamic {
                                id: 0usize,
                            },
                            {
                                dioxus_core::TemplateNode::Element {
                                    tag: dioxus_elements::elements::div::TAG_NAME,
                                    namespace: dioxus_elements::div::NAME_SPACE,
                                    attrs: &[
                                        dioxus_core::TemplateAttribute::Static {
                                            name: dioxus_elements::div::class.0,
                                            namespace: dioxus_elements::div::class.1,
                                            value: "absolute flex flex-row w-[100vw] h-[100vh]",
                                        },
                                    ],
                                    children: &[
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::div::TAG_NAME,
                                                namespace: dioxus_elements::div::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::div::class.0,
                                                        namespace: dioxus_elements::div::class.1,
                                                        value: "w-[50vw] h-[100vh]",
                                                    },
                                                    dioxus_core::TemplateAttribute::Dynamic {
                                                        id: 0usize,
                                                    },
                                                ],
                                                children: &[],
                                            }
                                        },
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::div::TAG_NAME,
                                                namespace: dioxus_elements::div::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::div::class.0,
                                                        namespace: dioxus_elements::div::class.1,
                                                        value: "w-[50vw] h-[100vh]",
                                                    },
                                                    dioxus_core::TemplateAttribute::Dynamic {
                                                        id: 1usize,
                                                    },
                                                ],
                                                children: &[],
                                            }
                                        },
                                    ],
                                }
                            },
                        ];
                        {
                            #[doc(hidden)]
                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                roots: __TEMPLATE_ROOTS,
                                node_paths: &[&[0u8]],
                                attr_paths: &[&[1u8, 0u8], &[1u8, 1u8]],
                            };
                            #[allow(clippy::let_and_return)]
                            let __vnodes = dioxus_core::VNode::new(
                                None,
                                ___TEMPLATE,
                                Box::new(__dynamic_nodes),
                                Box::new(__dynamic_attributes),
                            );
                            __vnodes
                        }
                    })
                }
            }
        }
        #[allow(non_snake_case)]
        #[doc(hidden)]
        mod Home_completions {
            #[doc(hidden)]
            #[allow(non_camel_case_types)]
            /// This enum is generated to help autocomplete the braces after the component. It does nothing
            pub enum Component {
                Home {},
            }
        }
        #[allow(unused)]
        pub use Home_completions::Component::Home;
        ///Properties for the [`Card`] component.
        #[allow(missing_docs)]
        #[allow(non_camel_case_types)]
        struct CardProps {
            class: String,
            url: ReadOnlySignal<String>,
        }
        impl CardProps {
            /**
Create a builder for building `CardProps`.
On the builder, call `.class(...)`, `.url(...)` to set the values of the fields.
Finally, call `.build()` to create the instance of `CardProps`.
                    */
            #[allow(dead_code, clippy::type_complexity)]
            fn builder() -> CardPropsBuilder<((), ())> {
                CardPropsBuilder {
                    owner: Owner::default(),
                    fields: ((), ()),
                    _phantom: ::core::default::Default::default(),
                }
            }
        }
        #[must_use]
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        struct CardPropsBuilder<TypedBuilderFields> {
            owner: Owner,
            fields: TypedBuilderFields,
            _phantom: (),
        }
        impl dioxus_core::prelude::Properties for CardProps
        where
            Self: Clone,
        {
            type Builder = CardPropsBuilder<((), ())>;
            fn builder() -> Self::Builder {
                CardProps::builder()
            }
            fn memoize(&mut self, new: &Self) -> bool {
                let exactly_equal = self == new;
                if exactly_equal {
                    return true;
                }
                let mut url = self.url;
                self.url = new.url;
                let non_signal_fields_equal = self == new;
                if !non_signal_fields_equal {
                    let new_clone = new.clone();
                    self.class = new_clone.class;
                }
                trait NonPartialEq: Sized {
                    fn compare(&self, other: &Self) -> bool;
                }
                impl<T> NonPartialEq for &&T {
                    fn compare(&self, other: &Self) -> bool {
                        false
                    }
                }
                trait CanPartialEq: PartialEq {
                    fn compare(&self, other: &Self) -> bool;
                }
                impl<T: PartialEq> CanPartialEq for T {
                    fn compare(&self, other: &Self) -> bool {
                        self == other
                    }
                }
                let field_eq = {
                    let old_value: &_ = &*url.peek();
                    let new_value: &_ = &*new.url.peek();
                    (&old_value).compare(&&new_value)
                };
                url.point_to(new.url).unwrap();
                if !field_eq {
                    (url).mark_dirty();
                }
                self.url = url;
                non_signal_fields_equal
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub trait CardPropsBuilder_Optional<T> {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T;
        }
        impl<T> CardPropsBuilder_Optional<T> for () {
            fn into_value<F: FnOnce() -> T>(self, default: F) -> T {
                default()
            }
        }
        impl<T> CardPropsBuilder_Optional<T> for (T,) {
            fn into_value<F: FnOnce() -> T>(self, _: F) -> T {
                self.0
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__url> CardPropsBuilder<((), __url)> {
            #[allow(clippy::type_complexity)]
            pub fn class(
                self,
                class: impl ::core::fmt::Display,
            ) -> CardPropsBuilder<((String,), __url)> {
                let class = (class.to_string(),);
                let (_, url) = self.fields;
                CardPropsBuilder {
                    owner: self.owner,
                    fields: (class, url),
                    _phantom: self._phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum CardPropsBuilder_Error_Repeated_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__url> CardPropsBuilder<((String,), __url)> {
            #[deprecated(note = "Repeated field class")]
            #[allow(clippy::type_complexity)]
            pub fn class(
                self,
                _: CardPropsBuilder_Error_Repeated_field_class,
            ) -> CardPropsBuilder<((String,), __url)> {
                self
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__class> CardPropsBuilder<(__class, ())> {
            #[allow(clippy::type_complexity)]
            pub fn url<__Marker>(
                self,
                url: impl dioxus_core::prelude::SuperInto<
                    ReadOnlySignal<String>,
                    __Marker,
                >,
            ) -> CardPropsBuilder<(__class, (ReadOnlySignal<String>,))> {
                let url = (
                    with_owner(
                        self.owner.clone(),
                        move || dioxus_core::prelude::SuperInto::super_into(url),
                    ),
                );
                let (class, _) = self.fields;
                CardPropsBuilder {
                    owner: self.owner,
                    fields: (class, url),
                    _phantom: self._phantom,
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum CardPropsBuilder_Error_Repeated_field_url {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl<__class> CardPropsBuilder<(__class, (ReadOnlySignal<String>,))> {
            #[deprecated(note = "Repeated field url")]
            #[allow(clippy::type_complexity)]
            pub fn url<__Marker>(
                self,
                _: CardPropsBuilder_Error_Repeated_field_url,
            ) -> CardPropsBuilder<(__class, (ReadOnlySignal<String>,))> {
                self
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum CardPropsBuilder_Error_Missing_required_field_class {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl<__url> CardPropsBuilder<((), __url)> {
            #[deprecated(note = "Missing required field class")]
            pub fn build(
                self,
                _: CardPropsBuilder_Error_Missing_required_field_class,
            ) -> CardProps {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, non_snake_case)]
        pub enum CardPropsBuilder_Error_Missing_required_field_url {}
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs, clippy::panic)]
        impl CardPropsBuilder<((String,), ())> {
            #[deprecated(note = "Missing required field url")]
            pub fn build(
                self,
                _: CardPropsBuilder_Error_Missing_required_field_url,
            ) -> CardProps {
                {
                    #[cold]
                    #[track_caller]
                    #[inline(never)]
                    const fn panic_cold_explicit() -> ! {
                        ::core::panicking::panic_explicit()
                    }
                    panic_cold_explicit();
                }
            }
        }
        #[doc(hidden)]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        struct CardPropsWithOwner {
            inner: CardProps,
            owner: dioxus_core::internal::generational_box::Owner,
        }
        #[automatically_derived]
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl ::core::clone::Clone for CardPropsWithOwner {
            #[inline]
            fn clone(&self) -> CardPropsWithOwner {
                CardPropsWithOwner {
                    inner: ::core::clone::Clone::clone(&self.inner),
                    owner: ::core::clone::Clone::clone(&self.owner),
                }
            }
        }
        impl PartialEq for CardPropsWithOwner {
            fn eq(&self, other: &Self) -> bool {
                self.inner.eq(&other.inner)
            }
        }
        impl CardPropsWithOwner {
            /// Create a component from the props.
            pub fn into_vcomponent<M: 'static>(
                self,
                render_fn: impl dioxus_core::prelude::ComponentFunction<CardProps, M>,
            ) -> dioxus_core::VComponent {
                use dioxus_core::prelude::ComponentFunction;
                let component_name = ::std::any::type_name_of_val(&render_fn);
                dioxus_core::VComponent::new(
                    move |wrapper: Self| render_fn.rebuild(wrapper.inner),
                    self,
                    component_name,
                )
            }
        }
        impl dioxus_core::prelude::Properties for CardPropsWithOwner {
            type Builder = ();
            fn builder() -> Self::Builder {
                ::core::panicking::panic("internal error: entered unreachable code")
            }
            fn memoize(&mut self, new: &Self) -> bool {
                self.inner.memoize(&new.inner)
            }
        }
        #[allow(dead_code, non_camel_case_types, missing_docs)]
        impl CardPropsBuilder<((String,), (ReadOnlySignal<String>,))> {
            pub fn build(self) -> CardPropsWithOwner {
                let (class, url) = self.fields;
                let class = class.0;
                let url = url.0;
                CardPropsWithOwner {
                    inner: CardProps { class, url },
                    owner: self.owner,
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        #[allow(non_camel_case_types)]
        impl ::core::clone::Clone for CardProps {
            #[inline]
            fn clone(&self) -> CardProps {
                CardProps {
                    class: ::core::clone::Clone::clone(&self.class),
                    url: ::core::clone::Clone::clone(&self.url),
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        #[allow(non_camel_case_types)]
        impl ::core::marker::StructuralPartialEq for CardProps {}
        #[automatically_derived]
        #[allow(missing_docs)]
        #[allow(non_camel_case_types)]
        impl ::core::cmp::PartialEq for CardProps {
            #[inline]
            fn eq(&self, other: &CardProps) -> bool {
                self.class == other.class && self.url == other.url
            }
        }
        /**# Props
*For details, see the [props struct definition](CardProps).**/
        ///- [`class`](CardProps::class) : `String`
        ///- [`url`](CardProps::url) : `ReadOnlySignal<String>`
        #[allow(non_snake_case)]
        fn Card(CardProps { mut class, mut url }: CardProps) -> Element {
            {
                dioxus_core::internal::verify_component_called_as_component(Card);
                {
                    const VIDEO: Asset = {
                        const __ASSET_HASH: &[u8] = &[
                            25u8, 173u8, 123u8, 9u8, 42u8, 108u8, 118u8, 132u8,
                        ];
                        const __ASSET_SOURCE_PATH: &'static str = "/Users/evanalmloff/Desktop/gitlucky/assets/minecraft.webm";
                        const __ASSET_OPTIONS: manganis::AssetOptions = AssetOptions::Unknown
                            .into_asset_options();
                        const __ASSET: manganis::BundledAsset = manganis::macro_helpers::create_bundled_asset(
                            __ASSET_SOURCE_PATH,
                            __ASSET_HASH,
                            __ASSET_OPTIONS,
                        );
                        const __BUFFER: manganis::macro_helpers::const_serialize::ConstVec<
                            u8,
                        > = manganis::macro_helpers::serialize_asset(&__ASSET);
                        const __BYTES: &[u8] = __BUFFER.as_ref();
                        const __LEN: usize = __BYTES.len();
                        #[link_section = "__DATA,manganis,regular,no_dead_strip"]
                        #[used]
                        static __LINK_SECTION: [u8; __LEN] = manganis::macro_helpers::copy_bytes(
                            __BYTES,
                        );
                        fn __keep_link_section() -> u8 {
                            unsafe { std::ptr::read_volatile(__LINK_SECTION.as_ptr()) }
                        }
                        manganis::Asset::new(__ASSET, __keep_link_section)
                    };
                    let files = use_resource(move || async move {
                            let response = reqwest::get(url()).await.unwrap();
                            let text = response.text().await.unwrap();
                            GitDiff::from_str(&text).unwrap()
                        })
                        .suspend()?
                        .read_unchecked();
                    dioxus_core::Element::Ok({
                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                            {
                                let ___nodes = (&files.files)
                                    .into_iter()
                                    .map(|file| {
                                        dioxus_core::Element::Ok({
                                            let __dynamic_nodes: [dioxus_core::DynamicNode; 2usize] = [
                                                dioxus_core::DynamicNode::Text(
                                                    dioxus_core::VText::new(
                                                        ::alloc::__export::must_use({
                                                            let res = ::alloc::fmt::format(
                                                                format_args!("{0} -> {1}", file.old_path, file.new_path),
                                                            );
                                                            res
                                                        }),
                                                    ),
                                                ),
                                                {
                                                    let ___nodes = (&file.changes)
                                                        .into_iter()
                                                        .map(|chunk| {
                                                            dioxus_core::Element::Ok({
                                                                let __dynamic_nodes: [dioxus_core::DynamicNode; 2usize] = [
                                                                    dioxus_core::DynamicNode::Text(
                                                                        dioxus_core::VText::new(
                                                                            ::alloc::__export::must_use({
                                                                                let res = ::alloc::fmt::format(
                                                                                    format_args!(
                                                                                        "{0} -> {1} @@ {2}",
                                                                                        chunk.old_location,
                                                                                        chunk.new_location,
                                                                                        chunk.context,
                                                                                    ),
                                                                                );
                                                                                res
                                                                            }),
                                                                        ),
                                                                    ),
                                                                    {
                                                                        let ___nodes = (&chunk.contents)
                                                                            .into_iter()
                                                                            .map(|line| {
                                                                                dioxus_core::Element::Ok({
                                                                                    let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                                                                        {
                                                                                            let ___nodes = (match line.status {
                                                                                                Status::Added => {
                                                                                                    dioxus_core::Element::Ok({
                                                                                                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                                                                                            dioxus_core::DynamicNode::Text(
                                                                                                                dioxus_core::VText::new((line.contents).to_string()),
                                                                                                            ),
                                                                                                        ];
                                                                                                        let __dynamic_attributes: [Box<
                                                                                                            [dioxus_core::Attribute],
                                                                                                        >; 0usize] = [];
                                                                                                        #[doc(hidden)]
                                                                                                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                                                                            {
                                                                                                                dioxus_core::TemplateNode::Element {
                                                                                                                    tag: dioxus_elements::elements::pre::TAG_NAME,
                                                                                                                    namespace: dioxus_elements::pre::NAME_SPACE,
                                                                                                                    attrs: &[
                                                                                                                        dioxus_core::TemplateAttribute::Static {
                                                                                                                            name: dioxus_elements::pre::class.0,
                                                                                                                            namespace: dioxus_elements::pre::class.1,
                                                                                                                            value: "whitespace-pre truncate bg-[rgba(200,255,200,.8)]",
                                                                                                                        },
                                                                                                                    ],
                                                                                                                    children: &[
                                                                                                                        {
                                                                                                                            dioxus_core::TemplateNode::Element {
                                                                                                                                tag: dioxus_elements::elements::span::TAG_NAME,
                                                                                                                                namespace: dioxus_elements::span::NAME_SPACE,
                                                                                                                                attrs: &[
                                                                                                                                    dioxus_core::TemplateAttribute::Static {
                                                                                                                                        name: dioxus_elements::span::class.0,
                                                                                                                                        namespace: dioxus_elements::span::class.1,
                                                                                                                                        value: "p-2",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                                children: &[
                                                                                                                                    dioxus_core::TemplateNode::Text {
                                                                                                                                        text: "+",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                            }
                                                                                                                        },
                                                                                                                        dioxus_core::TemplateNode::Dynamic {
                                                                                                                            id: 0usize,
                                                                                                                        },
                                                                                                                    ],
                                                                                                                }
                                                                                                            },
                                                                                                        ];
                                                                                                        {
                                                                                                            #[doc(hidden)]
                                                                                                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                                                                                roots: __TEMPLATE_ROOTS,
                                                                                                                node_paths: &[&[0u8, 1u8]],
                                                                                                                attr_paths: &[],
                                                                                                            };
                                                                                                            #[allow(clippy::let_and_return)]
                                                                                                            let __vnodes = dioxus_core::VNode::new(
                                                                                                                None,
                                                                                                                ___TEMPLATE,
                                                                                                                Box::new(__dynamic_nodes),
                                                                                                                Box::new(__dynamic_attributes),
                                                                                                            );
                                                                                                            __vnodes
                                                                                                        }
                                                                                                    })
                                                                                                }
                                                                                                Status::Removed => {
                                                                                                    dioxus_core::Element::Ok({
                                                                                                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                                                                                            dioxus_core::DynamicNode::Text(
                                                                                                                dioxus_core::VText::new((line.contents).to_string()),
                                                                                                            ),
                                                                                                        ];
                                                                                                        let __dynamic_attributes: [Box<
                                                                                                            [dioxus_core::Attribute],
                                                                                                        >; 0usize] = [];
                                                                                                        #[doc(hidden)]
                                                                                                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                                                                            {
                                                                                                                dioxus_core::TemplateNode::Element {
                                                                                                                    tag: dioxus_elements::elements::pre::TAG_NAME,
                                                                                                                    namespace: dioxus_elements::pre::NAME_SPACE,
                                                                                                                    attrs: &[
                                                                                                                        dioxus_core::TemplateAttribute::Static {
                                                                                                                            name: dioxus_elements::pre::class.0,
                                                                                                                            namespace: dioxus_elements::pre::class.1,
                                                                                                                            value: "whitespace-pre truncate bg-[rgba(255,200,200,.8)]",
                                                                                                                        },
                                                                                                                    ],
                                                                                                                    children: &[
                                                                                                                        {
                                                                                                                            dioxus_core::TemplateNode::Element {
                                                                                                                                tag: dioxus_elements::elements::span::TAG_NAME,
                                                                                                                                namespace: dioxus_elements::span::NAME_SPACE,
                                                                                                                                attrs: &[
                                                                                                                                    dioxus_core::TemplateAttribute::Static {
                                                                                                                                        name: dioxus_elements::span::class.0,
                                                                                                                                        namespace: dioxus_elements::span::class.1,
                                                                                                                                        value: "p-2",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                                children: &[
                                                                                                                                    dioxus_core::TemplateNode::Text {
                                                                                                                                        text: "-",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                            }
                                                                                                                        },
                                                                                                                        dioxus_core::TemplateNode::Dynamic {
                                                                                                                            id: 0usize,
                                                                                                                        },
                                                                                                                    ],
                                                                                                                }
                                                                                                            },
                                                                                                        ];
                                                                                                        {
                                                                                                            #[doc(hidden)]
                                                                                                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                                                                                roots: __TEMPLATE_ROOTS,
                                                                                                                node_paths: &[&[0u8, 1u8]],
                                                                                                                attr_paths: &[],
                                                                                                            };
                                                                                                            #[allow(clippy::let_and_return)]
                                                                                                            let __vnodes = dioxus_core::VNode::new(
                                                                                                                None,
                                                                                                                ___TEMPLATE,
                                                                                                                Box::new(__dynamic_nodes),
                                                                                                                Box::new(__dynamic_attributes),
                                                                                                            );
                                                                                                            __vnodes
                                                                                                        }
                                                                                                    })
                                                                                                }
                                                                                                Status::Unchanged => {
                                                                                                    dioxus_core::Element::Ok({
                                                                                                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                                                                                                            dioxus_core::DynamicNode::Text(
                                                                                                                dioxus_core::VText::new((line.contents).to_string()),
                                                                                                            ),
                                                                                                        ];
                                                                                                        let __dynamic_attributes: [Box<
                                                                                                            [dioxus_core::Attribute],
                                                                                                        >; 0usize] = [];
                                                                                                        #[doc(hidden)]
                                                                                                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                                                                            {
                                                                                                                dioxus_core::TemplateNode::Element {
                                                                                                                    tag: dioxus_elements::elements::pre::TAG_NAME,
                                                                                                                    namespace: dioxus_elements::pre::NAME_SPACE,
                                                                                                                    attrs: &[
                                                                                                                        dioxus_core::TemplateAttribute::Static {
                                                                                                                            name: dioxus_elements::pre::class.0,
                                                                                                                            namespace: dioxus_elements::pre::class.1,
                                                                                                                            value: "whitespace-pre truncate",
                                                                                                                        },
                                                                                                                    ],
                                                                                                                    children: &[
                                                                                                                        {
                                                                                                                            dioxus_core::TemplateNode::Element {
                                                                                                                                tag: dioxus_elements::elements::span::TAG_NAME,
                                                                                                                                namespace: dioxus_elements::span::NAME_SPACE,
                                                                                                                                attrs: &[
                                                                                                                                    dioxus_core::TemplateAttribute::Static {
                                                                                                                                        name: dioxus_elements::span::class.0,
                                                                                                                                        namespace: dioxus_elements::span::class.1,
                                                                                                                                        value: "p-2",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                                children: &[
                                                                                                                                    dioxus_core::TemplateNode::Text {
                                                                                                                                        text: " ",
                                                                                                                                    },
                                                                                                                                ],
                                                                                                                            }
                                                                                                                        },
                                                                                                                        dioxus_core::TemplateNode::Dynamic {
                                                                                                                            id: 0usize,
                                                                                                                        },
                                                                                                                    ],
                                                                                                                }
                                                                                                            },
                                                                                                        ];
                                                                                                        {
                                                                                                            #[doc(hidden)]
                                                                                                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                                                                                roots: __TEMPLATE_ROOTS,
                                                                                                                node_paths: &[&[0u8, 1u8]],
                                                                                                                attr_paths: &[],
                                                                                                            };
                                                                                                            #[allow(clippy::let_and_return)]
                                                                                                            let __vnodes = dioxus_core::VNode::new(
                                                                                                                None,
                                                                                                                ___TEMPLATE,
                                                                                                                Box::new(__dynamic_nodes),
                                                                                                                Box::new(__dynamic_attributes),
                                                                                                            );
                                                                                                            __vnodes
                                                                                                        }
                                                                                                    })
                                                                                                }
                                                                                            })
                                                                                                .into_dyn_node();
                                                                                            ___nodes
                                                                                        },
                                                                                    ];
                                                                                    let __dynamic_attributes: [Box<
                                                                                        [dioxus_core::Attribute],
                                                                                    >; 0usize] = [];
                                                                                    #[doc(hidden)]
                                                                                    static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                                                        dioxus_core::TemplateNode::Dynamic {
                                                                                            id: 0usize,
                                                                                        },
                                                                                    ];
                                                                                    {
                                                                                        #[doc(hidden)]
                                                                                        static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                                                            roots: __TEMPLATE_ROOTS,
                                                                                            node_paths: &[&[0u8]],
                                                                                            attr_paths: &[],
                                                                                        };
                                                                                        #[allow(clippy::let_and_return)]
                                                                                        let __vnodes = dioxus_core::VNode::new(
                                                                                            None,
                                                                                            ___TEMPLATE,
                                                                                            Box::new(__dynamic_nodes),
                                                                                            Box::new(__dynamic_attributes),
                                                                                        );
                                                                                        __vnodes
                                                                                    }
                                                                                })
                                                                            })
                                                                            .into_dyn_node();
                                                                        ___nodes
                                                                    },
                                                                ];
                                                                let __dynamic_attributes: [Box<
                                                                    [dioxus_core::Attribute],
                                                                >; 0usize] = [];
                                                                #[doc(hidden)]
                                                                static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                                    {
                                                                        dioxus_core::TemplateNode::Element {
                                                                            tag: dioxus_elements::elements::div::TAG_NAME,
                                                                            namespace: dioxus_elements::div::NAME_SPACE,
                                                                            attrs: &[
                                                                                dioxus_core::TemplateAttribute::Static {
                                                                                    name: dioxus_elements::div::class.0,
                                                                                    namespace: dioxus_elements::div::class.1,
                                                                                    value: "flex flex-row w-[100vw] border-b pl-8 sticky top-[25px] h-[25px] overflow-ellipsis overflow-clip bg-[rgba(195,195,195)]",
                                                                                },
                                                                            ],
                                                                            children: &[
                                                                                dioxus_core::TemplateNode::Dynamic {
                                                                                    id: 0usize,
                                                                                },
                                                                            ],
                                                                        }
                                                                    },
                                                                    dioxus_core::TemplateNode::Dynamic {
                                                                        id: 1usize,
                                                                    },
                                                                ];
                                                                {
                                                                    #[doc(hidden)]
                                                                    static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                                        roots: __TEMPLATE_ROOTS,
                                                                        node_paths: &[&[0u8, 0u8], &[1u8]],
                                                                        attr_paths: &[],
                                                                    };
                                                                    #[allow(clippy::let_and_return)]
                                                                    let __vnodes = dioxus_core::VNode::new(
                                                                        None,
                                                                        ___TEMPLATE,
                                                                        Box::new(__dynamic_nodes),
                                                                        Box::new(__dynamic_attributes),
                                                                    );
                                                                    __vnodes
                                                                }
                                                            })
                                                        })
                                                        .into_dyn_node();
                                                    ___nodes
                                                },
                                            ];
                                            let __dynamic_attributes: [Box<
                                                [dioxus_core::Attribute],
                                            >; 0usize] = [];
                                            #[doc(hidden)]
                                            static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                                                {
                                                    dioxus_core::TemplateNode::Element {
                                                        tag: dioxus_elements::elements::div::TAG_NAME,
                                                        namespace: dioxus_elements::div::NAME_SPACE,
                                                        attrs: &[
                                                            dioxus_core::TemplateAttribute::Static {
                                                                name: dioxus_elements::div::class.0,
                                                                namespace: dioxus_elements::div::class.1,
                                                                value: "flex flex-row w-[100vw] border-t font-bold pl-8 sticky h-[25px] top-0 overflow-ellipsis overflow-clip bg-[rgba(195,195,195)]",
                                                            },
                                                        ],
                                                        children: &[
                                                            dioxus_core::TemplateNode::Dynamic {
                                                                id: 0usize,
                                                            },
                                                        ],
                                                    }
                                                },
                                                {
                                                    dioxus_core::TemplateNode::Element {
                                                        tag: dioxus_elements::elements::div::TAG_NAME,
                                                        namespace: dioxus_elements::div::NAME_SPACE,
                                                        attrs: &[
                                                            dioxus_core::TemplateAttribute::Static {
                                                                name: dioxus_elements::div::class.0,
                                                                namespace: dioxus_elements::div::class.1,
                                                                value: "flex flex-col w-[100vw]",
                                                            },
                                                        ],
                                                        children: &[
                                                            dioxus_core::TemplateNode::Dynamic {
                                                                id: 1usize,
                                                            },
                                                        ],
                                                    }
                                                },
                                            ];
                                            {
                                                #[doc(hidden)]
                                                static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                                    roots: __TEMPLATE_ROOTS,
                                                    node_paths: &[&[0u8, 0u8], &[1u8, 0u8]],
                                                    attr_paths: &[],
                                                };
                                                #[allow(clippy::let_and_return)]
                                                let __vnodes = dioxus_core::VNode::new(
                                                    None,
                                                    ___TEMPLATE,
                                                    Box::new(__dynamic_nodes),
                                                    Box::new(__dynamic_attributes),
                                                );
                                                __vnodes
                                            }
                                        })
                                    })
                                    .into_dyn_node();
                                ___nodes
                            },
                        ];
                        let __dynamic_attributes: [Box<
                            [dioxus_core::Attribute],
                        >; 5usize] = [
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::div::class.0,
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!("w-[100vw] h-[100vh] {0}", class),
                                            );
                                            res
                                        }),
                                        dioxus_elements::div::class.1,
                                        dioxus_elements::div::class.2,
                                    )
                                },
                            ]),
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::video::autoplay.0,
                                        true,
                                        dioxus_elements::video::autoplay.1,
                                        dioxus_elements::video::autoplay.2,
                                    )
                                },
                            ]),
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::video::r#loop.0,
                                        true,
                                        dioxus_elements::video::r#loop.1,
                                        dioxus_elements::video::r#loop.2,
                                    )
                                },
                            ]),
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::video::muted.0,
                                        true,
                                        dioxus_elements::video::muted.1,
                                        dioxus_elements::video::muted.2,
                                    )
                                },
                            ]),
                            Box::new([
                                {
                                    dioxus_core::Attribute::new(
                                        dioxus_elements::source::src.0,
                                        VIDEO,
                                        dioxus_elements::source::src.1,
                                        dioxus_elements::source::src.2,
                                    )
                                },
                            ]),
                        ];
                        #[doc(hidden)]
                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                            {
                                dioxus_core::TemplateNode::Element {
                                    tag: dioxus_elements::elements::div::TAG_NAME,
                                    namespace: dioxus_elements::div::NAME_SPACE,
                                    attrs: &[
                                        dioxus_core::TemplateAttribute::Dynamic {
                                            id: 0usize,
                                        },
                                    ],
                                    children: &[
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::div::TAG_NAME,
                                                namespace: dioxus_elements::div::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::div::class.0,
                                                        namespace: dioxus_elements::div::class.1,
                                                        value: "absolute flex flex-col w-[100vw] h-[100vh] font-mono",
                                                    },
                                                ],
                                                children: &[
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::video::TAG_NAME,
                                                            namespace: dioxus_elements::video::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Dynamic {
                                                                    id: 1usize,
                                                                },
                                                                dioxus_core::TemplateAttribute::Dynamic {
                                                                    id: 2usize,
                                                                },
                                                                dioxus_core::TemplateAttribute::Dynamic {
                                                                    id: 3usize,
                                                                },
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::video::class.0,
                                                                    namespace: dioxus_elements::video::class.1,
                                                                    value: "w-[100vw] h-full object-cover",
                                                                },
                                                            ],
                                                            children: &[
                                                                {
                                                                    dioxus_core::TemplateNode::Element {
                                                                        tag: dioxus_elements::elements::source::TAG_NAME,
                                                                        namespace: dioxus_elements::source::NAME_SPACE,
                                                                        attrs: &[
                                                                            dioxus_core::TemplateAttribute::Dynamic {
                                                                                id: 4usize,
                                                                            },
                                                                            dioxus_core::TemplateAttribute::Static {
                                                                                name: dioxus_elements::source::r#type.0,
                                                                                namespace: dioxus_elements::source::r#type.1,
                                                                                value: "video/webm",
                                                                            },
                                                                        ],
                                                                        children: &[],
                                                                    }
                                                                },
                                                            ],
                                                        }
                                                    },
                                                ],
                                            }
                                        },
                                        {
                                            dioxus_core::TemplateNode::Element {
                                                tag: dioxus_elements::elements::div::TAG_NAME,
                                                namespace: dioxus_elements::div::NAME_SPACE,
                                                attrs: &[
                                                    dioxus_core::TemplateAttribute::Static {
                                                        name: dioxus_elements::div::class.0,
                                                        namespace: dioxus_elements::div::class.1,
                                                        value: "absolute w-[100vw] h-[100vh] font-mono overflow-y-scroll rounded-t-lg",
                                                    },
                                                ],
                                                children: &[
                                                    {
                                                        dioxus_core::TemplateNode::Element {
                                                            tag: dioxus_elements::elements::div::TAG_NAME,
                                                            namespace: dioxus_elements::div::NAME_SPACE,
                                                            attrs: &[
                                                                dioxus_core::TemplateAttribute::Static {
                                                                    name: dioxus_elements::div::class.0,
                                                                    namespace: dioxus_elements::div::class.1,
                                                                    value: "flex flex-col backdrop-blur-xs bg-[rgba(255,255,255,0.5)]",
                                                                },
                                                            ],
                                                            children: &[
                                                                dioxus_core::TemplateNode::Dynamic {
                                                                    id: 0usize,
                                                                },
                                                            ],
                                                        }
                                                    },
                                                ],
                                            }
                                        },
                                    ],
                                }
                            },
                        ];
                        {
                            #[doc(hidden)]
                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                roots: __TEMPLATE_ROOTS,
                                node_paths: &[&[0u8, 1u8, 0u8, 0u8]],
                                attr_paths: &[
                                    &[0u8],
                                    &[0u8, 0u8, 0u8],
                                    &[0u8, 0u8, 0u8],
                                    &[0u8, 0u8, 0u8],
                                    &[0u8, 0u8, 0u8, 0u8],
                                ],
                            };
                            #[allow(clippy::let_and_return)]
                            let __vnodes = dioxus_core::VNode::new(
                                None,
                                ___TEMPLATE,
                                Box::new(__dynamic_nodes),
                                Box::new(__dynamic_attributes),
                            );
                            __vnodes
                        }
                    })
                }
            }
        }
        #[allow(non_snake_case)]
        #[doc(hidden)]
        mod Card_completions {
            #[doc(hidden)]
            #[allow(non_camel_case_types)]
            /// This enum is generated to help autocomplete the braces after the component. It does nothing
            pub enum Component {
                Card {},
            }
        }
        #[allow(unused)]
        use Card_completions::Component::Card;
        struct GitDiff {
            files: Vec<GitDiffFile>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GitDiff {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GitDiff",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "files",
                        &self.files,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GitDiff {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "files" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"files" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GitDiff>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GitDiff;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GitDiff",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Vec<GitDiffFile>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GitDiff with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GitDiff { files: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Vec<GitDiffFile>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("files"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<GitDiffFile>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("files")?
                                }
                            };
                            _serde::__private::Ok(GitDiff { files: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["files"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GitDiff",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GitDiff>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl FromStr for GitDiff {
            type Err = std::io::Error;
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                let mut files = Vec::new();
                let mut lines = s.split_inclusive("\n").peekable();
                while let Some(line) = lines.next() {
                    if let Some(from_file) = line.strip_prefix("---") {
                        let line = lines.next();
                        if let Some(to_file) = line
                            .and_then(|line| line.strip_prefix("+++"))
                        {
                            let old_path = from_file.trim().to_string();
                            let new_path = to_file.trim().to_string();
                            let mut changes = Vec::new();
                            while let Some(line) = lines
                                .next_if(|line| !line.starts_with("---"))
                            {
                                if let Some(line) = line.strip_prefix("@@ ") {
                                    if let Some((location, context)) = line.split_once("@@") {
                                        if let Some((old, new)) = location.split_once(" ") {
                                            if let (Ok(old_location), Ok(new_location)) = (
                                                old.trim_matches('-').parse(),
                                                new.trim_matches('+').parse(),
                                            ) {
                                                changes
                                                    .push(GitDiffChange {
                                                        context: context.trim().to_string(),
                                                        old_location,
                                                        new_location,
                                                        contents: Vec::new(),
                                                    });
                                            }
                                        }
                                    }
                                } else if let Some(line) = line.strip_prefix("+") {
                                    changes
                                        .last_mut()
                                        .unwrap()
                                        .contents
                                        .push(Line {
                                            contents: line.to_string(),
                                            status: Status::Added,
                                        })
                                } else if let Some(line) = line.strip_prefix("-") {
                                    changes
                                        .last_mut()
                                        .unwrap()
                                        .contents
                                        .push(Line {
                                            contents: line.to_string(),
                                            status: Status::Removed,
                                        })
                                } else if let Some(line) = line.strip_prefix(" ") {
                                    changes
                                        .last_mut()
                                        .unwrap()
                                        .contents
                                        .push(Line {
                                            contents: line.to_string(),
                                            status: Status::Unchanged,
                                        })
                                }
                            }
                            files
                                .push(GitDiffFile {
                                    old_path,
                                    new_path,
                                    changes,
                                });
                        }
                    }
                }
                Ok(Self { files })
            }
        }
        struct GitDiffFile {
            old_path: String,
            new_path: String,
            changes: Vec<GitDiffChange>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GitDiffFile {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GitDiffFile",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "old_path",
                        &self.old_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "new_path",
                        &self.new_path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "changes",
                        &self.changes,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GitDiffFile {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "old_path" => _serde::__private::Ok(__Field::__field0),
                                "new_path" => _serde::__private::Ok(__Field::__field1),
                                "changes" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"old_path" => _serde::__private::Ok(__Field::__field0),
                                b"new_path" => _serde::__private::Ok(__Field::__field1),
                                b"changes" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GitDiffFile>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GitDiffFile;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GitDiffFile",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GitDiffFile with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GitDiffFile with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<GitDiffChange>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GitDiffFile with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GitDiffFile {
                                old_path: __field0,
                                new_path: __field1,
                                changes: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<GitDiffChange>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "old_path",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "new_path",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "changes",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<GitDiffChange>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("old_path")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("new_path")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("changes")?
                                }
                            };
                            _serde::__private::Ok(GitDiffFile {
                                old_path: __field0,
                                new_path: __field1,
                                changes: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "old_path",
                        "new_path",
                        "changes",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GitDiffFile",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GitDiffFile>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct GitDiffChange {
            context: String,
            old_location: Location,
            new_location: Location,
            contents: Vec<Line>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GitDiffChange {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GitDiffChange",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "context",
                        &self.context,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "old_location",
                        &self.old_location,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "new_location",
                        &self.new_location,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "contents",
                        &self.contents,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GitDiffChange {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "context" => _serde::__private::Ok(__Field::__field0),
                                "old_location" => _serde::__private::Ok(__Field::__field1),
                                "new_location" => _serde::__private::Ok(__Field::__field2),
                                "contents" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"context" => _serde::__private::Ok(__Field::__field0),
                                b"old_location" => _serde::__private::Ok(__Field::__field1),
                                b"new_location" => _serde::__private::Ok(__Field::__field2),
                                b"contents" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GitDiffChange>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GitDiffChange;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GitDiffChange",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GitDiffChange with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Location,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GitDiffChange with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Location,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct GitDiffChange with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<Line>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct GitDiffChange with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GitDiffChange {
                                context: __field0,
                                old_location: __field1,
                                new_location: __field2,
                                contents: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Location> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Location> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Vec<Line>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "context",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "old_location",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Location>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "new_location",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Location>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "contents",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<Line>>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("context")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("old_location")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("new_location")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("contents")?
                                }
                            };
                            _serde::__private::Ok(GitDiffChange {
                                context: __field0,
                                old_location: __field1,
                                new_location: __field2,
                                contents: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "context",
                        "old_location",
                        "new_location",
                        "contents",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GitDiffChange",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<GitDiffChange>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct Line {
            contents: String,
            status: Status,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Line {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Line",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "contents",
                        &self.contents,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "status",
                        &self.status,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Line {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "contents" => _serde::__private::Ok(__Field::__field0),
                                "status" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"contents" => _serde::__private::Ok(__Field::__field0),
                                b"status" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Line>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Line;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Line",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Line with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Status,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Line with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Line {
                                contents: __field0,
                                status: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Status> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "contents",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Status>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("contents")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("status")?
                                }
                            };
                            _serde::__private::Ok(Line {
                                contents: __field0,
                                status: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["contents", "status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Line",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Line>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        enum Status {
            Added,
            Removed,
            Unchanged,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Status {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Status::Added => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Status",
                                0u32,
                                "Added",
                            )
                        }
                        Status::Removed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Status",
                                1u32,
                                "Removed",
                            )
                        }
                        Status::Unchanged => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "Status",
                                2u32,
                                "Unchanged",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Status {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Added" => _serde::__private::Ok(__Field::__field0),
                                "Removed" => _serde::__private::Ok(__Field::__field1),
                                "Unchanged" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Added" => _serde::__private::Ok(__Field::__field0),
                                b"Removed" => _serde::__private::Ok(__Field::__field1),
                                b"Unchanged" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Status>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Status;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Status",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Status::Added)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Status::Removed)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(Status::Unchanged)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Added",
                        "Removed",
                        "Unchanged",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Status",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Status>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Status {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Status {
            #[inline]
            fn eq(&self, other: &Status) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        struct Location {
            line_number: usize,
            column_number: usize,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Location {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Location",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "line_number",
                        &self.line_number,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "column_number",
                        &self.column_number,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Location {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "line_number" => _serde::__private::Ok(__Field::__field0),
                                "column_number" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"line_number" => _serde::__private::Ok(__Field::__field0),
                                b"column_number" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Location>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Location;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Location",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Location with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Location with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Location {
                                line_number: __field0,
                                column_number: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "line_number",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "column_number",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("line_number")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("column_number")?
                                }
                            };
                            _serde::__private::Ok(Location {
                                line_number: __field0,
                                column_number: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "line_number",
                        "column_number",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Location",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Location>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Display for Location {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(
                    format_args!("{0}:{1}", self.line_number, self.column_number),
                )
            }
        }
        impl FromStr for Location {
            type Err = ();
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                let s = s.trim();
                match s.split_once(',') {
                    Some((line, column)) => {
                        line.parse()
                            .and_then(|line_number| {
                                column
                                    .parse()
                                    .map(|column_number| Self { line_number, column_number })
                            })
                            .map_err(|_| {})
                    }
                    None => {
                        s.parse()
                            .map(|line_number| Self {
                                line_number,
                                column_number: 0,
                            })
                            .map_err(|_| {})
                    }
                }
            }
        }
    }
    pub use home::Home;
}
#[rustfmt::skip]
enum Route {
    #[route("/")]
    Home {},
}
#[automatically_derived]
impl ::core::fmt::Debug for Route {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(f, "Home")
    }
}
#[automatically_derived]
impl ::core::clone::Clone for Route {
    #[inline]
    fn clone(&self) -> Route {
        Route::Home {}
    }
}
const _: () = {
    /// An error that can occur when trying to parse the route variant `/`.
    #[allow(non_camel_case_types)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub enum HomeParseError {
        /// An error that can occur when extra segments are provided after the route.
        ExtraSegments(String),
        /// An error that can occur when trying to parse the static segment '/'.
        StaticSegment0ParseError(String),
    }
    impl std::fmt::Debug for HomeParseError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("{0}({1})", "HomeParseError", self))
        }
    }
    impl std::fmt::Display for HomeParseError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::ExtraSegments(segments) => {
                    f.write_fmt(
                        format_args!("Found additional trailing segments: {0}", segments),
                    )?
                }
                Self::StaticSegment0ParseError(found) => {
                    f.write_fmt(
                        format_args!(
                            "Static segment \'{0}\' did not match instead found \'{1}\'",
                            "",
                            found,
                        ),
                    )?
                }
            }
            Ok(())
        }
    }
    /// An error that can occur when trying to parse the route enum [`Route`].
    #[allow(non_camel_case_types)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    pub enum RouteMatchError {
        /// An error that can occur when trying to parse the route [`Route::Home`] ('/').
        Home(HomeParseError),
    }
    impl std::fmt::Debug for RouteMatchError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("{0}({1})", "RouteMatchError", self))
        }
    }
    impl std::fmt::Display for RouteMatchError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Home(err) => {
                    f.write_fmt(
                        format_args!(
                            "Route \'{0}\' (\'{1}\') did not match:\n{2}",
                            "Home",
                            "/",
                            err,
                        ),
                    )?
                }
            }
            Ok(())
        }
    }
    impl std::fmt::Display for Route {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            #[allow(unused)]
            match self {
                Self::Home {} => {
                    f.write_fmt(format_args!("/{0}", ""))?;
                }
            }
            Ok(())
        }
    }
    impl dioxus_router::routable::Routable for Route
    where
        Self: Clone,
    {
        const SITE_MAP: &'static [dioxus_router::routable::SiteMapSegment] = &[
            dioxus_router::routable::SiteMapSegment {
                segment_type: dioxus_router::routable::SegmentType::Static(""),
                children: &[],
            },
        ];
        fn render(&self, level: usize) -> dioxus_core::Element {
            let myself = self.clone();
            match (level, myself) {
                #[allow(unused)]
                (0usize, Self::Home {}) => {
                    dioxus_core::Element::Ok({
                        let __dynamic_nodes: [dioxus_core::DynamicNode; 1usize] = [
                            dioxus_core::DynamicNode::Component({
                                use dioxus_core::prelude::Properties;
                                let __comp = ({ fc_to_builder(Home).build() })
                                    .into_vcomponent(Home);
                                __comp
                            }),
                        ];
                        let __dynamic_attributes: [Box<
                            [dioxus_core::Attribute],
                        >; 0usize] = [];
                        #[doc(hidden)]
                        static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                            dioxus_core::TemplateNode::Dynamic {
                                id: 0usize,
                            },
                        ];
                        {
                            #[doc(hidden)]
                            static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                                roots: __TEMPLATE_ROOTS,
                                node_paths: &[&[0u8]],
                                attr_paths: &[],
                            };
                            #[allow(clippy::let_and_return)]
                            let __vnodes = dioxus_core::VNode::new(
                                None,
                                ___TEMPLATE,
                                Box::new(__dynamic_nodes),
                                Box::new(__dynamic_attributes),
                            );
                            __vnodes
                        }
                    })
                }
                _ => VNode::empty(),
            }
        }
    }
    impl<'a> core::convert::TryFrom<&'a str> for Route {
        type Error = <Self as std::str::FromStr>::Err;
        fn try_from(s: &'a str) -> ::std::result::Result<Self, Self::Error> {
            s.parse()
        }
    }
    impl std::str::FromStr for Route {
        type Err = dioxus_router::routable::RouteParseError<RouteMatchError>;
        fn from_str(s: &str) -> ::std::result::Result<Self, Self::Err> {
            let route = s;
            let (route, hash) = route.split_once('#').unwrap_or((route, ""));
            let (route, query) = route.split_once('?').unwrap_or((route, ""));
            let route = route.strip_suffix('/').unwrap_or(route);
            let query = dioxus_router::exports::urlencoding::decode(query)
                .unwrap_or(query.into());
            let hash = dioxus_router::exports::urlencoding::decode(hash)
                .unwrap_or(hash.into());
            let mut segments = route
                .split('/')
                .map(|s| {
                    dioxus_router::exports::urlencoding::decode(s).unwrap_or(s.into())
                });
            if s.starts_with('/') {
                let _ = segments.next();
            } else {
                return Err(dioxus_router::routable::RouteParseError {
                    attempted_routes: Vec::new(),
                });
            }
            let mut errors = Vec::new();
            {
                let remaining_segments = segments.clone();
                let mut segments_clone = segments.clone();
                let next_segment = segments_clone.next();
                if next_segment.is_none() {
                    return Ok(Route::Home {});
                } else {
                    let mut trailing = String::new();
                    for seg in remaining_segments {
                        trailing += &*seg;
                        trailing += "/";
                    }
                    trailing.pop();
                    errors
                        .push(
                            RouteMatchError::Home(
                                HomeParseError::ExtraSegments(trailing),
                            ),
                        )
                }
            }
            Err(dioxus_router::routable::RouteParseError {
                attempted_routes: errors,
            })
        }
    }
};
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for Route {}
#[automatically_derived]
impl ::core::cmp::PartialEq for Route {
    #[inline]
    fn eq(&self, other: &Route) -> bool {
        true
    }
}
const FAVICON: Asset = {
    const __ASSET_HASH: &[u8] = &[177u8, 191u8, 45u8, 97u8, 39u8, 244u8, 198u8, 145u8];
    const __ASSET_SOURCE_PATH: &'static str = "/Users/evanalmloff/Desktop/gitlucky/assets/favicon.ico";
    const __ASSET_OPTIONS: manganis::AssetOptions = manganis::AssetOptions::Unknown
        .into_asset_options();
    const __ASSET: manganis::BundledAsset = manganis::macro_helpers::create_bundled_asset(
        __ASSET_SOURCE_PATH,
        __ASSET_HASH,
        __ASSET_OPTIONS,
    );
    const __BUFFER: manganis::macro_helpers::const_serialize::ConstVec<u8> = manganis::macro_helpers::serialize_asset(
        &__ASSET,
    );
    const __BYTES: &[u8] = __BUFFER.as_ref();
    const __LEN: usize = __BYTES.len();
    #[link_section = "__DATA,manganis,regular,no_dead_strip"]
    #[used]
    static __LINK_SECTION: [u8; __LEN] = manganis::macro_helpers::copy_bytes(__BYTES);
    fn __keep_link_section() -> u8 {
        unsafe { std::ptr::read_volatile(__LINK_SECTION.as_ptr()) }
    }
    manganis::Asset::new(__ASSET, __keep_link_section)
};
const TAILWIND_CSS: Asset = {
    const __ASSET_HASH: &[u8] = &[214u8, 109u8, 194u8, 11u8, 45u8, 231u8, 144u8, 1u8];
    const __ASSET_SOURCE_PATH: &'static str = "/Users/evanalmloff/Desktop/gitlucky/assets/tailwind.css";
    const __ASSET_OPTIONS: manganis::AssetOptions = manganis::AssetOptions::Unknown
        .into_asset_options();
    const __ASSET: manganis::BundledAsset = manganis::macro_helpers::create_bundled_asset(
        __ASSET_SOURCE_PATH,
        __ASSET_HASH,
        __ASSET_OPTIONS,
    );
    const __BUFFER: manganis::macro_helpers::const_serialize::ConstVec<u8> = manganis::macro_helpers::serialize_asset(
        &__ASSET,
    );
    const __BYTES: &[u8] = __BUFFER.as_ref();
    const __LEN: usize = __BYTES.len();
    #[link_section = "__DATA,manganis,regular,no_dead_strip"]
    #[used]
    static __LINK_SECTION: [u8; __LEN] = manganis::macro_helpers::copy_bytes(__BYTES);
    fn __keep_link_section() -> u8 {
        unsafe { std::ptr::read_volatile(__LINK_SECTION.as_ptr()) }
    }
    manganis::Asset::new(__ASSET, __keep_link_section)
};
fn main() {
    dioxus::launch(App);
}
#[allow(non_snake_case)]
fn App() -> Element {
    {
        dioxus_core::internal::verify_component_called_as_component(App);
        {
            dioxus_core::Element::Ok({
                let __dynamic_nodes: [dioxus_core::DynamicNode; 3usize] = [
                    dioxus_core::DynamicNode::Component({
                        use dioxus_core::prelude::Properties;
                        let __comp = ({
                            fc_to_builder(document::Link)
                                .rel({ { "icon" } })
                                .href(FAVICON)
                                .build()
                        })
                            .into_vcomponent(document::Link);
                        __comp
                    }),
                    dioxus_core::DynamicNode::Component({
                        use dioxus_core::prelude::Properties;
                        let __comp = ({
                            fc_to_builder(document::Link)
                                .rel({ { "stylesheet" } })
                                .href(TAILWIND_CSS)
                                .build()
                        })
                            .into_vcomponent(document::Link);
                        __comp
                    }),
                    dioxus_core::DynamicNode::Component({
                        use dioxus_core::prelude::Properties;
                        let __comp = ({ fc_to_builder(Router::<Route>).build() })
                            .into_vcomponent(Router::<Route>);
                        __comp
                    }),
                ];
                let __dynamic_attributes: [Box<[dioxus_core::Attribute]>; 0usize] = [];
                #[doc(hidden)]
                static __TEMPLATE_ROOTS: &[dioxus_core::TemplateNode] = &[
                    dioxus_core::TemplateNode::Dynamic {
                        id: 0usize,
                    },
                    dioxus_core::TemplateNode::Dynamic {
                        id: 1usize,
                    },
                    dioxus_core::TemplateNode::Dynamic {
                        id: 2usize,
                    },
                ];
                {
                    #[doc(hidden)]
                    static ___TEMPLATE: dioxus_core::Template = dioxus_core::Template {
                        roots: __TEMPLATE_ROOTS,
                        node_paths: &[&[0u8], &[1u8], &[2u8]],
                        attr_paths: &[],
                    };
                    #[allow(clippy::let_and_return)]
                    let __vnodes = dioxus_core::VNode::new(
                        None,
                        ___TEMPLATE,
                        Box::new(__dynamic_nodes),
                        Box::new(__dynamic_attributes),
                    );
                    __vnodes
                }
            })
        }
    }
}
#[allow(non_snake_case)]
#[doc(hidden)]
mod App_completions {
    #[doc(hidden)]
    #[allow(non_camel_case_types)]
    /// This enum is generated to help autocomplete the braces after the component. It does nothing
    pub enum Component {
        App {},
    }
}
#[allow(unused)]
use App_completions::Component::App;
